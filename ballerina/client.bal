// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# Preview of the Discord v10 HTTP API specification. See https://discord.com/developers/docs for more details.
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig? apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://discord.com/api/v10") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        if config.auth is ApiKeysConfig {
            self.apiKeyConfig = (<ApiKeysConfig>config.auth).cloneReadOnly();
        } else {
            httpClientConfig.auth = <OAuth2ClientCredentialsGrantConfig|http:BearerTokenConfig|OAuth2RefreshTokenGrantConfig>config.auth;
            self.apiKeyConfig = ();
        }
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # get_my_oauth2_application
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_my_oauth2_application 
    resource isolated function get oauth2/applications/\@me(map<string|string[]> headers = {}) returns PrivateApplicationResponse|error {
        string resourcePath = string `/oauth2/applications/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_my_connections
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_my_connections 
    resource isolated function get users/\@me/connections(map<string|string[]> headers = {}) returns ConnectedAccountResponse[]|error {
        string resourcePath = string `/users/@me/connections`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_dm
    #
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_dm 
    resource isolated function post users/\@me/channels(CreatePrivateChannelRequest payload, map<string|string[]> headers = {}) returns InlineResponse200|error {
        string resourcePath = string `/users/@me/channels`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_my_guilds
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_my_guilds 
    resource isolated function get users/\@me/guilds(map<string|string[]> headers = {}, *ListMyGuildsQueries queries) returns MyGuildResponse[]|error {
        string resourcePath = string `/users/@me/guilds`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_my_application
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_my_application 
    resource isolated function get applications/\@me(map<string|string[]> headers = {}) returns PrivateApplicationResponse|error {
        string resourcePath = string `/applications/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_my_application
    #
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_my_application 
    resource isolated function patch applications/\@me(ApplicationFormPartial payload, map<string|string[]> headers = {}) returns PrivateApplicationResponse|error {
        string resourcePath = string `/applications/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_bot_gateway
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_bot_gateway 
    resource isolated function get gateway/bot(map<string|string[]> headers = {}) returns GatewayBotResponse|error {
        string resourcePath = string `/gateway/bot`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_public_keys
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_public_keys 
    resource isolated function get oauth2/keys(map<string|string[]> headers = {}) returns OAuth2GetKeys|error {
        string resourcePath = string `/oauth2/keys`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_my_oauth2_authorization
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_my_oauth2_authorization 
    resource isolated function get oauth2/\@me(map<string|string[]> headers = {}) returns OAuth2GetAuthorizationResponse|error {
        string resourcePath = string `/oauth2/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_voice_regions
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_voice_regions 
    resource isolated function get voice/regions(map<string|string[]> headers = {}) returns VoiceRegionResponse[]|error {
        string resourcePath = string `/voice/regions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_my_user
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_my_user 
    resource isolated function get users/\@me(map<string|string[]> headers = {}) returns UserPIIResponse|error {
        string resourcePath = string `/users/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_my_user
    #
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_my_user 
    resource isolated function patch users/\@me(BotAccountPatchRequest payload, map<string|string[]> headers = {}) returns UserPIIResponse|error {
        string resourcePath = string `/users/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # create_stage_instance
    #
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_stage_instance 
    resource isolated function post stage\-instances(StageInstancesRequest payload, map<string|string[]> headers = {}) returns StageInstanceResponse|error {
        string resourcePath = string `/stage-instances`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_sticker_packs
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_sticker_packs 
    resource isolated function get sticker\-packs(map<string|string[]> headers = {}) returns StickerPackCollectionResponse|error {
        string resourcePath = string `/sticker-packs`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_gateway
    #
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_gateway 
    resource isolated function get gateway(map<string|string[]> headers = {}) returns GatewayResponse|error {
        string resourcePath = string `/gateway`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild
    #
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_guild 
    resource isolated function post guilds(GuildCreateRequest payload, map<string|string[]> headers = {}) returns GuildResponse|error {
        string resourcePath = string `/guilds`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_my_private_archived_threads
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_my_private_archived_threads 
    resource isolated function get channels/[string channelId]/users/\@me/threads/archived/'private(map<string|string[]> headers = {}, *ListMyPrivateArchivedThreadsQueries queries) returns ThreadsResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/users/@me/threads/archived/private`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_guild_application_command_permissions
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_application_command_permissions 
    resource isolated function get applications/[string applicationId]/guilds/[string guildId]/commands/permissions(map<string|string[]> headers = {}) returns CommandPermissionsResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/permissions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_application_command_permissions
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_application_command_permissions 
    resource isolated function get applications/[string applicationId]/guilds/[string guildId]/commands/[string commandId]/permissions(map<string|string[]> headers = {}) returns CommandPermissionsResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/${getEncodedUri(commandId)}/permissions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # set_guild_application_command_permissions
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for set_guild_application_command_permissions 
    resource isolated function put applications/[string applicationId]/guilds/[string guildId]/commands/[string commandId]/permissions(ApplicationsGuildsCommandsCommandIdPermissionsRequest payload, map<string|string[]> headers = {}) returns CommandPermissionsResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/${getEncodedUri(commandId)}/permissions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # add_my_message_reaction
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + emojiName -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for add_my_message_reaction 
    resource isolated function put channels/[string channelId]/messages/[string messageId]/reactions/[string emojiName]/\@me(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions/${getEncodedUri(emojiName)}/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_my_message_reaction
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + emojiName -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_my_message_reaction 
    resource isolated function delete channels/[string channelId]/messages/[string messageId]/reactions/[string emojiName]/\@me(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions/${getEncodedUri(emojiName)}/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_private_archived_threads
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_private_archived_threads 
    resource isolated function get channels/[string channelId]/threads/archived/'private(map<string|string[]> headers = {}, *ListPrivateArchivedThreadsQueries queries) returns ThreadsResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/threads/archived/private`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_public_archived_threads
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_public_archived_threads 
    resource isolated function get channels/[string channelId]/threads/archived/'public(map<string|string[]> headers = {}, *ListPublicArchivedThreadsQueries queries) returns ThreadsResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/threads/archived/public`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_application_user_role_connection
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_application_user_role_connection 
    resource isolated function get users/\@me/applications/[string applicationId]/role\-connection(map<string|string[]> headers = {}) returns ApplicationUserRoleConnectionResponse|error {
        string resourcePath = string `/users/@me/applications/${getEncodedUri(applicationId)}/role-connection`;
        return self.clientEp->get(resourcePath, headers);
    }

    # update_application_user_role_connection
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_application_user_role_connection 
    resource isolated function put users/\@me/applications/[string applicationId]/role\-connection(UsersMeApplicationsRoleConnectionRequest payload, map<string|string[]> headers = {}) returns ApplicationUserRoleConnectionResponse|error {
        string resourcePath = string `/users/@me/applications/${getEncodedUri(applicationId)}/role-connection`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # get_my_guild_member
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_my_guild_member 
    resource isolated function get users/\@me/guilds/[string guildId]/member(map<string|string[]> headers = {}) returns PrivateGuildMemberResponse|error {
        string resourcePath = string `/users/@me/guilds/${getEncodedUri(guildId)}/member`;
        return self.clientEp->get(resourcePath, headers);
    }

    # get_application_role_connections_metadata
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_application_role_connections_metadata 
    resource isolated function get applications/[string applicationId]/role\-connections/metadata(map<string|string[]> headers = {}) returns ApplicationRoleConnectionsMetadataItemResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/role-connections/metadata`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_application_role_connections_metadata
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_application_role_connections_metadata 
    resource isolated function put applications/[string applicationId]/role\-connections/metadata(ApplicationRoleConnectionsMetadataItemRequest[] payload, map<string|string[]> headers = {}) returns ApplicationRoleConnectionsMetadataItemResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/role-connections/metadata`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # consume_entitlement
    #
    # + applicationId - Application ID
    # + entitlementId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for consume_entitlement 
    resource isolated function post applications/[string applicationId]/entitlements/[string entitlementId]/consume(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/entitlements/${getEncodedUri(entitlementId)}/consume`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_application_command
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_application_command 
    resource isolated function get applications/[string applicationId]/guilds/[string guildId]/commands/[string commandId](map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_guild_application_command
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_application_command 
    resource isolated function delete applications/[string applicationId]/guilds/[string guildId]/commands/[string commandId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_application_command
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_application_command 
    resource isolated function patch applications/[string applicationId]/guilds/[string guildId]/commands/[string commandId](ApplicationCommandPatchRequestPartial payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_application_commands
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_application_commands 
    resource isolated function get applications/[string applicationId]/guilds/[string guildId]/commands(map<string|string[]> headers = {}, *ListGuildApplicationCommandsQueries queries) returns ApplicationCommandResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # bulk_set_guild_application_commands
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for bulk_set_guild_application_commands 
    resource isolated function put applications/[string applicationId]/guilds/[string guildId]/commands(ApplicationCommandUpdateRequest[] payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # create_guild_application_command
    #
    # + applicationId - Application ID
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_guild_application_command 
    resource isolated function post applications/[string applicationId]/guilds/[string guildId]/commands(ApplicationCommandCreateRequest payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/guilds/${getEncodedUri(guildId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # join_thread
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for join_thread 
    resource isolated function put channels/[string channelId]/thread\-members/\@me(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # leave_thread
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for leave_thread 
    resource isolated function delete channels/[string channelId]/thread\-members/\@me(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # bulk_delete_messages
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for bulk_delete_messages 
    resource isolated function post channels/[string channelId]/messages/bulk\-delete(ChannelsMessagesBulkDeleteRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/bulk-delete`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # delete_user_message_reaction
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + emojiName -
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_user_message_reaction 
    resource isolated function delete channels/[string channelId]/messages/[string messageId]/reactions/[string emojiName]/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions/${getEncodedUri(emojiName)}/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_message_reactions_by_emoji
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + emojiName -
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_message_reactions_by_emoji 
    resource isolated function get channels/[string channelId]/messages/[string messageId]/reactions/[string emojiName](map<string|string[]> headers = {}, *ListMessageReactionsByEmojiQueries queries) returns UserResponse[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions/${getEncodedUri(emojiName)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_all_message_reactions_by_emoji
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + emojiName -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_all_message_reactions_by_emoji 
    resource isolated function delete channels/[string channelId]/messages/[string messageId]/reactions/[string emojiName](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions/${getEncodedUri(emojiName)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # delete_all_message_reactions
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_all_message_reactions 
    resource isolated function delete channels/[string channelId]/messages/[string messageId]/reactions(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/reactions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # crosspost_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for crosspost_message 
    resource isolated function post channels/[string channelId]/messages/[string messageId]/crosspost(map<string|string[]> headers = {}) returns MessageResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/crosspost`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # create_thread_from_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_thread_from_message 
    resource isolated function post channels/[string channelId]/messages/[string messageId]/threads(CreateTextThreadWithMessageRequest payload, map<string|string[]> headers = {}) returns ThreadResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}/threads`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_original_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_original_webhook_message 
    resource isolated function get webhooks/[string webhookId]/[string webhookToken]/messages/\@original(map<string|string[]> headers = {}, *GetOriginalWebhookMessageQueries queries) returns MessageResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/@original`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_original_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 204 response for delete_original_webhook_message 
    resource isolated function delete webhooks/[string webhookId]/[string webhookToken]/messages/\@original(map<string|string[]> headers = {}, *DeleteOriginalWebhookMessageQueries queries) returns error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/@original`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_original_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for update_original_webhook_message 
    resource isolated function patch webhooks/[string webhookId]/[string webhookToken]/messages/\@original(UpdateOriginalWebhookMessageHeaders headers, MessagesoriginalBody payload, *UpdateOriginalWebhookMessageQueries queries) returns MessageResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/@original`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_scheduled_event_users
    #
    # + guildId - Guild ID
    # + guildScheduledEventId -
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_scheduled_event_users 
    resource isolated function get guilds/[string guildId]/scheduled\-events/[string guildScheduledEventId]/users(map<string|string[]> headers = {}, *ListGuildScheduledEventUsersQueries queries) returns ScheduledEventUserResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events/${getEncodedUri(guildScheduledEventId)}/users`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_auto_moderation_rule
    #
    # + guildId - Guild ID
    # + ruleId -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_auto_moderation_rule 
    resource isolated function get guilds/[string guildId]/auto\-moderation/rules/[string ruleId](map<string|string[]> headers = {}) returns InlineResponse2001|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/auto-moderation/rules/${getEncodedUri(ruleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_auto_moderation_rule
    #
    # + guildId - Guild ID
    # + ruleId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_auto_moderation_rule 
    resource isolated function delete guilds/[string guildId]/auto\-moderation/rules/[string ruleId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/auto-moderation/rules/${getEncodedUri(ruleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_auto_moderation_rule
    #
    # + guildId - Guild ID
    # + ruleId -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_auto_moderation_rule 
    resource isolated function patch guilds/[string guildId]/auto\-moderation/rules/[string ruleId](RulesruleIdBody payload, map<string|string[]> headers = {}) returns InlineResponse2001|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/auto-moderation/rules/${getEncodedUri(ruleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_auto_moderation_rules
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_auto_moderation_rules 
    resource isolated function get guilds/[string guildId]/auto\-moderation/rules(map<string|string[]> headers = {}) returns InlineResponseItems200[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/auto-moderation/rules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_auto_moderation_rule
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_auto_moderation_rule 
    resource isolated function post guilds/[string guildId]/auto\-moderation/rules(AutoModerationRulesBody payload, map<string|string[]> headers = {}) returns InlineResponse2001|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/auto-moderation/rules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # update_self_voice_state
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for update_self_voice_state 
    resource isolated function patch guilds/[string guildId]/voice\-states/\@me(GuildsVoiceStatesMeRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/voice-states/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # search_guild_members
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for search_guild_members 
    resource isolated function get guilds/[string guildId]/members/search(map<string|string[]> headers = {}, *SearchGuildMembersQueries queries) returns GuildMemberResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/search`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_active_guild_threads
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_active_guild_threads 
    resource isolated function get guilds/[string guildId]/threads/active(map<string|string[]> headers = {}) returns ThreadsResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/threads/active`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_my_guild_member
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_my_guild_member 
    resource isolated function patch guilds/[string guildId]/members/\@me(GuildsMembersMeRequest payload, map<string|string[]> headers = {}) returns PrivateGuildMemberResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/@me`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # add_guild_member_role
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + roleId - Role ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for add_guild_member_role 
    resource isolated function put guilds/[string guildId]/members/[string userId]/roles/[string roleId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}/roles/${getEncodedUri(roleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_guild_member_role
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + roleId - Role ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_member_role 
    resource isolated function delete guilds/[string guildId]/members/[string userId]/roles/[string roleId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}/roles/${getEncodedUri(roleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # leave_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for leave_guild 
    resource isolated function delete users/\@me/guilds/[string guildId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/users/@me/guilds/${getEncodedUri(guildId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # get_entitlement
    #
    # + applicationId - Application ID
    # + entitlementId -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_entitlement 
    resource isolated function get applications/[string applicationId]/entitlements/[string entitlementId](map<string|string[]> headers = {}) returns EntitlementResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/entitlements/${getEncodedUri(entitlementId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_entitlement
    #
    # + applicationId - Application ID
    # + entitlementId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_entitlement 
    resource isolated function delete applications/[string applicationId]/entitlements/[string entitlementId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/entitlements/${getEncodedUri(entitlementId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # get_entitlements
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_entitlements 
    resource isolated function get applications/[string applicationId]/entitlements(map<string|string[]> headers = {}, *GetEntitlementsQueries queries) returns InlineResponseItems2001[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/entitlements`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<Encoding> queryParamEncoding = {"sku_ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_entitlement
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_entitlement 
    resource isolated function post applications/[string applicationId]/entitlements(CreateEntitlementRequestData payload, map<string|string[]> headers = {}) returns EntitlementResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/entitlements`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_application_command
    #
    # + applicationId - Application ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_application_command 
    resource isolated function get applications/[string applicationId]/commands/[string commandId](map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_application_command
    #
    # + applicationId - Application ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_application_command 
    resource isolated function delete applications/[string applicationId]/commands/[string commandId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_application_command
    #
    # + applicationId - Application ID
    # + commandId - Command ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_application_command 
    resource isolated function patch applications/[string applicationId]/commands/[string commandId](ApplicationCommandPatchRequestPartial payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands/${getEncodedUri(commandId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_application_commands
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_application_commands 
    resource isolated function get applications/[string applicationId]/commands(map<string|string[]> headers = {}, *ListApplicationCommandsQueries queries) returns ApplicationCommandResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # bulk_set_application_commands
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for bulk_set_application_commands 
    resource isolated function put applications/[string applicationId]/commands(ApplicationCommandUpdateRequest[] payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse[]|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # create_application_command
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_application_command 
    resource isolated function post applications/[string applicationId]/commands(ApplicationCommandCreateRequest payload, map<string|string[]> headers = {}) returns ApplicationCommandResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}/commands`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # create_interaction_response
    #
    # + interactionId -
    # + interactionToken -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for create_interaction_response 
    resource isolated function post interactions/[string interactionId]/[string interactionToken]/callback(InteractionTokenCallbackBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/interactions/${getEncodedUri(interactionId)}/${getEncodedUri(interactionToken)}/callback`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_thread_member
    #
    # + channelId - Channel ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_thread_member 
    resource isolated function get channels/[string channelId]/thread\-members/[string userId](map<string|string[]> headers = {}, *GetThreadMemberQueries queries) returns ThreadMemberResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # add_thread_member
    #
    # + channelId - Channel ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for add_thread_member 
    resource isolated function put channels/[string channelId]/thread\-members/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_thread_member
    #
    # + channelId - Channel ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_thread_member 
    resource isolated function delete channels/[string channelId]/thread\-members/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_thread_members
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_thread_members 
    resource isolated function get channels/[string channelId]/thread\-members(map<string|string[]> headers = {}, *ListThreadMembersQueries queries) returns ThreadMemberResponse[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/thread-members`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # set_channel_permission_overwrite
    #
    # + channelId - Channel ID
    # + overwriteId -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for set_channel_permission_overwrite 
    resource isolated function put channels/[string channelId]/permissions/[string overwriteId](ChannelsPermissionsRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/permissions/${getEncodedUri(overwriteId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_channel_permission_overwrite
    #
    # + channelId - Channel ID
    # + overwriteId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_channel_permission_overwrite 
    resource isolated function delete channels/[string channelId]/permissions/[string overwriteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/permissions/${getEncodedUri(overwriteId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # add_group_dm_user
    #
    # + channelId - Channel ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for add_group_dm_user 
    resource isolated function put channels/[string channelId]/recipients/[string userId](ChannelsRecipientsRequest payload, map<string|string[]> headers = {}) returns InlineResponse200|error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/recipients/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_group_dm_user
    #
    # + channelId - Channel ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_group_dm_user 
    resource isolated function delete channels/[string channelId]/recipients/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/recipients/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # follow_channel
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for follow_channel 
    resource isolated function post channels/[string channelId]/followers(ChannelsFollowersRequest payload, map<string|string[]> headers = {}) returns ChannelFollowerResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/followers`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_message 
    resource isolated function get channels/[string channelId]/messages/[string messageId](map<string|string[]> headers = {}) returns MessageResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_message 
    resource isolated function delete channels/[string channelId]/messages/[string messageId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for update_message 
    resource isolated function patch channels/[string channelId]/messages/[string messageId](UpdateMessageHeaders headers, MessagesmessageIdBody payload) returns MessageResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_messages
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_messages 
    resource isolated function get channels/[string channelId]/messages(map<string|string[]> headers = {}, *ListMessagesQueries queries) returns MessageResponse[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_message
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for create_message 
    resource isolated function post channels/[string channelId]/messages(CreateMessageHeaders headers, ChannelIdMessagesBody payload) returns MessageResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/messages`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_channel_webhooks
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_channel_webhooks 
    resource isolated function get channels/[string channelId]/webhooks(map<string|string[]> headers = {}) returns InlineResponseItems2002[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/webhooks`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_webhook
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_webhook 
    resource isolated function post channels/[string channelId]/webhooks(ChannelsWebhooksRequest payload, map<string|string[]> headers = {}) returns GuildIncomingWebhookResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/webhooks`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_channel_invites
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_channel_invites 
    resource isolated function get channels/[string channelId]/invites(map<string|string[]> headers = {}) returns InlineResponseItems2003[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/invites`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_channel_invite
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_channel_invite 
    resource isolated function post channels/[string channelId]/invites(ChannelIdInvitesBody payload, map<string|string[]> headers = {}) returns InlineResponse2002|error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/invites`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # create_thread
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_thread 
    resource isolated function post channels/[string channelId]/threads(ChannelIdThreadsBody payload, map<string|string[]> headers = {}) returns CreatedThreadResponse|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/threads`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # trigger_typing_indicator
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for trigger_typing_indicator 
    resource isolated function post channels/[string channelId]/typing(map<string|string[]> headers = {}) returns record {}|error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/typing`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # pin_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for pin_message 
    resource isolated function put channels/[string channelId]/pins/[string messageId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/pins/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # unpin_message
    #
    # + channelId - Channel ID
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for unpin_message 
    resource isolated function delete channels/[string channelId]/pins/[string messageId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/pins/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_pinned_messages
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_pinned_messages 
    resource isolated function get channels/[string channelId]/pins(map<string|string[]> headers = {}) returns MessageResponse[]|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}/pins`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_webhook_message 
    resource isolated function get webhooks/[string webhookId]/[string webhookToken]/messages/[string messageId](map<string|string[]> headers = {}, *GetWebhookMessageQueries queries) returns MessageResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 204 response for delete_webhook_message 
    resource isolated function delete webhooks/[string webhookId]/[string webhookToken]/messages/[string messageId](map<string|string[]> headers = {}, *DeleteWebhookMessageQueries queries) returns error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_webhook_message
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + messageId - Message ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for update_webhook_message 
    resource isolated function patch webhooks/[string webhookId]/[string webhookToken]/messages/[string messageId](UpdateWebhookMessageHeaders headers, MessagesmessageIdBody1 payload, *UpdateWebhookMessageQueries queries) returns MessageResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/messages/${getEncodedUri(messageId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # execute_github_compatible_webhook
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload -
    # + return - 204 response for execute_github_compatible_webhook 
    resource isolated function post webhooks/[string webhookId]/[string webhookToken]/github(GithubWebhook payload, map<string|string[]> headers = {}, *ExecuteGithubCompatibleWebhookQueries queries) returns error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/github`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # execute_slack_compatible_webhook
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for execute_slack_compatible_webhook 
    resource isolated function post webhooks/[string webhookId]/[string webhookToken]/slack(ExecuteSlackCompatibleWebhookHeaders headers, WebhookTokenSlackBody payload, *ExecuteSlackCompatibleWebhookQueries queries) returns string?|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}/slack`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_template
    #
    # + code -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_template 
    resource isolated function get guilds/templates/[string code](map<string|string[]> headers = {}) returns GuildTemplateResponse|error {
        string resourcePath = string `/guilds/templates/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_from_template
    #
    # + code -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_guild_from_template 
    resource isolated function post guilds/templates/[string code](GuildsTemplatesRequest payload, map<string|string[]> headers = {}) returns GuildResponse|error {
        string resourcePath = string `/guilds/templates/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_new_member_welcome
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_new_member_welcome 
    resource isolated function get guilds/[string guildId]/new\-member\-welcome(map<string|string[]> headers = {}) returns GuildHomeSettingsResponse|error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/new-member-welcome`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_scheduled_event
    #
    # + guildId - Guild ID
    # + guildScheduledEventId -
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_guild_scheduled_event 
    resource isolated function get guilds/[string guildId]/scheduled\-events/[string guildScheduledEventId](map<string|string[]> headers = {}, *GetGuildScheduledEventQueries queries) returns InlineResponse2003|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events/${getEncodedUri(guildScheduledEventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_guild_scheduled_event
    #
    # + guildId - Guild ID
    # + guildScheduledEventId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_scheduled_event 
    resource isolated function delete guilds/[string guildId]/scheduled\-events/[string guildScheduledEventId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events/${getEncodedUri(guildScheduledEventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_voice_state
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for update_voice_state 
    resource isolated function patch guilds/[string guildId]/scheduled\-events/[string guildScheduledEventId](ScheduledEventsguildScheduledEventIdBody payload, map<string|string[]> headers = {}) returns InlineResponse2003|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events/${getEncodedUri(guildScheduledEventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_scheduled_events
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_scheduled_events 
    resource isolated function get guilds/[string guildId]/scheduled\-events(map<string|string[]> headers = {}, *ListGuildScheduledEventsQueries queries) returns InlineResponseItems2004[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_scheduled_event
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_guild_scheduled_event 
    resource isolated function post guilds/[string guildId]/scheduled\-events(GuildIdScheduledEventsBody payload, map<string|string[]> headers = {}) returns InlineResponse2003|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/scheduled-events`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_welcome_screen
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_welcome_screen 
    resource isolated function get guilds/[string guildId]/welcome\-screen(map<string|string[]> headers = {}) returns GuildWelcomeScreenResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/welcome-screen`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_guild_welcome_screen
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_welcome_screen 
    resource isolated function patch guilds/[string guildId]/welcome\-screen(WelcomeScreenPatchRequestPartial payload, map<string|string[]> headers = {}) returns GuildWelcomeScreenResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/welcome-screen`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # update_voice_state
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for update_voice_state 
    resource isolated function patch guilds/[string guildId]/voice\-states/[string userId](GuildsVoiceStatesRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/voice-states/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # delete_guild_integration
    #
    # + guildId - Guild ID
    # + integrationId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_integration 
    resource isolated function delete guilds/[string guildId]/integrations/[string integrationId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/integrations/${getEncodedUri(integrationId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_guild_integrations
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_integrations 
    resource isolated function get guilds/[string guildId]/integrations(map<string|string[]> headers = {}) returns InlineResponseItems2005[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/integrations`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_widget
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_widget 
    resource isolated function get guilds/[string guildId]/widget\.json(map<string|string[]> headers = {}) returns WidgetResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/widget.json`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guilds_onboarding
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guilds_onboarding 
    resource isolated function get guilds/[string guildId]/onboarding(map<string|string[]> headers = {}) returns UserGuildOnboardingResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/onboarding`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # put_guilds_onboarding
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for put_guilds_onboarding 
    resource isolated function put guilds/[string guildId]/onboarding(UpdateGuildOnboardingRequest payload, map<string|string[]> headers = {}) returns GuildOnboardingResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/onboarding`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # get_guild_vanity_url
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_vanity_url 
    resource isolated function get guilds/[string guildId]/vanity\-url(map<string|string[]> headers = {}) returns VanityURLResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/vanity-url`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_guild_audit_log_entries
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_audit_log_entries 
    resource isolated function get guilds/[string guildId]/audit\-logs(map<string|string[]> headers = {}, *ListGuildAuditLogEntriesQueries queries) returns GuildAuditLogResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/audit-logs`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_widget_png
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_guild_widget_png 
    resource isolated function get guilds/[string guildId]/widget\.png(map<string|string[]> headers = {}, *GetGuildWidgetPngQueries queries) returns byte[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/widget.png`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<Encoding> queryParamEncoding = {"style": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # sync_guild_template
    #
    # + guildId - Guild ID
    # + code -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for sync_guild_template 
    resource isolated function put guilds/[string guildId]/templates/[string code](map<string|string[]> headers = {}) returns GuildTemplateResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/templates/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_guild_template
    #
    # + guildId - Guild ID
    # + code -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for delete_guild_template 
    resource isolated function delete guilds/[string guildId]/templates/[string code](map<string|string[]> headers = {}) returns GuildTemplateResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/templates/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_template
    #
    # + guildId - Guild ID
    # + code -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_template 
    resource isolated function patch guilds/[string guildId]/templates/[string code](GuildsTemplatesRequest1 payload, map<string|string[]> headers = {}) returns GuildTemplateResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/templates/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_templates
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_templates 
    resource isolated function get guilds/[string guildId]/templates(map<string|string[]> headers = {}) returns GuildTemplateResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/templates`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_template
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_guild_template 
    resource isolated function post guilds/[string guildId]/templates(GuildsTemplatesRequest2 payload, map<string|string[]> headers = {}) returns GuildTemplateResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/templates`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_sticker
    #
    # + guildId - Guild ID
    # + stickerId -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_sticker 
    resource isolated function get guilds/[string guildId]/stickers/[string stickerId](map<string|string[]> headers = {}) returns GuildStickerResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/stickers/${getEncodedUri(stickerId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_guild_sticker
    #
    # + guildId - Guild ID
    # + stickerId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_sticker 
    resource isolated function delete guilds/[string guildId]/stickers/[string stickerId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/stickers/${getEncodedUri(stickerId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_sticker
    #
    # + guildId - Guild ID
    # + stickerId -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_sticker 
    resource isolated function patch guilds/[string guildId]/stickers/[string stickerId](GuildsStickersRequest payload, map<string|string[]> headers = {}) returns GuildStickerResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/stickers/${getEncodedUri(stickerId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # bulk_ban_users_from_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for bulk_ban_users_from_guild 
    resource isolated function post guilds/[string guildId]/bulk\-ban(GuildsBulkBanRequest payload, map<string|string[]> headers = {}) returns BulkBanUsersResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/bulk-ban`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # list_guild_stickers
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_stickers 
    resource isolated function get guilds/[string guildId]/stickers(map<string|string[]> headers = {}) returns GuildStickerResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/stickers`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_sticker
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 201 response for create_guild_sticker 
    resource isolated function post guilds/[string guildId]/stickers(GuildIdStickersBody payload, map<string|string[]> headers = {}) returns GuildStickerResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/stickers`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_webhooks
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_webhooks 
    resource isolated function get guilds/[string guildId]/webhooks(map<string|string[]> headers = {}) returns InlineResponseItems2006[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/webhooks`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_guild_channels
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_channels 
    resource isolated function get guilds/[string guildId]/channels(map<string|string[]> headers = {}) returns InlineResponseItems2007[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/channels`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_channel
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_guild_channel 
    resource isolated function post guilds/[string guildId]/channels(CreateGuildChannelRequest payload, map<string|string[]> headers = {}) returns GuildChannelResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/channels`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # bulk_update_guild_channels
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for bulk_update_guild_channels 
    resource isolated function patch guilds/[string guildId]/channels(GuildsChannelsRequest[] payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/channels`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_guild_member
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_member 
    resource isolated function get guilds/[string guildId]/members/[string userId](map<string|string[]> headers = {}) returns GuildMemberResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # add_guild_member
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for add_guild_member 
    resource isolated function put guilds/[string guildId]/members/[string userId](GuildsMembersRequest payload, map<string|string[]> headers = {}) returns GuildMemberResponse|error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # delete_guild_member
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_member 
    resource isolated function delete guilds/[string guildId]/members/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_member
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_member 
    resource isolated function patch guilds/[string guildId]/members/[string userId](GuildsMembersRequest1 payload, map<string|string[]> headers = {}) returns GuildMemberResponse|error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_members
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_members 
    resource isolated function get guilds/[string guildId]/members(map<string|string[]> headers = {}, *ListGuildMembersQueries queries) returns GuildMemberResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/members`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_preview
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_preview 
    resource isolated function get guilds/[string guildId]/preview(map<string|string[]> headers = {}) returns GuildPreviewResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/preview`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_guild_invites
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_invites 
    resource isolated function get guilds/[string guildId]/invites(map<string|string[]> headers = {}) returns InlineResponseItems2008[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/invites`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # list_guild_voice_regions
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_voice_regions 
    resource isolated function get guilds/[string guildId]/regions(map<string|string[]> headers = {}) returns VoiceRegionResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/regions`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_guild_emoji
    #
    # + guildId - Guild ID
    # + emojiId -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_emoji 
    resource isolated function get guilds/[string guildId]/emojis/[string emojiId](map<string|string[]> headers = {}) returns EmojiResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/emojis/${getEncodedUri(emojiId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_guild_emoji
    #
    # + guildId - Guild ID
    # + emojiId -
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_emoji 
    resource isolated function delete guilds/[string guildId]/emojis/[string emojiId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/emojis/${getEncodedUri(emojiId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_emoji
    #
    # + guildId - Guild ID
    # + emojiId -
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_emoji 
    resource isolated function patch guilds/[string guildId]/emojis/[string emojiId](GuildsEmojisRequest payload, map<string|string[]> headers = {}) returns EmojiResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/emojis/${getEncodedUri(emojiId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_emojis
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_emojis 
    resource isolated function get guilds/[string guildId]/emojis(map<string|string[]> headers = {}) returns EmojiResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/emojis`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_emoji
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 201 response for create_guild_emoji 
    resource isolated function post guilds/[string guildId]/emojis(GuildsEmojisRequest1 payload, map<string|string[]> headers = {}) returns EmojiResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/emojis`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_widget_settings
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_widget_settings 
    resource isolated function get guilds/[string guildId]/widget(map<string|string[]> headers = {}) returns WidgetSettingsResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/widget`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_guild_widget_settings
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_widget_settings 
    resource isolated function patch guilds/[string guildId]/widget(GuildsWidgetRequest payload, map<string|string[]> headers = {}) returns WidgetSettingsResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/widget`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # delete_guild_role
    #
    # + guildId - Guild ID
    # + roleId - Role ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild_role 
    resource isolated function delete guilds/[string guildId]/roles/[string roleId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/roles/${getEncodedUri(roleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild_role
    #
    # + guildId - Guild ID
    # + roleId - Role ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild_role 
    resource isolated function patch guilds/[string guildId]/roles/[string roleId](GuildsRolesRequest payload, map<string|string[]> headers = {}) returns GuildRoleResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/roles/${getEncodedUri(roleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # list_guild_roles
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for list_guild_roles 
    resource isolated function get guilds/[string guildId]/roles(map<string|string[]> headers = {}) returns GuildRoleResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/roles`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # create_guild_role
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for create_guild_role 
    resource isolated function post guilds/[string guildId]/roles(GuildsRolesRequest payload, map<string|string[]> headers = {}) returns GuildRoleResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/roles`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # bulk_update_guild_roles
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for bulk_update_guild_roles 
    resource isolated function patch guilds/[string guildId]/roles(GuildsRolesRequest2[] payload, map<string|string[]> headers = {}) returns GuildRoleResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/roles`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # preview_prune_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for preview_prune_guild 
    resource isolated function get guilds/[string guildId]/prune(map<string|string[]> headers = {}, *PreviewPruneGuildQueries queries) returns GuildPruneResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/prune`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<Encoding> queryParamEncoding = {"include_roles": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # prune_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for prune_guild 
    resource isolated function post guilds/[string guildId]/prune(GuildsPruneRequest payload, map<string|string[]> headers = {}) returns GuildPruneResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/prune`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_guild_ban
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_guild_ban 
    resource isolated function get guilds/[string guildId]/bans/[string userId](map<string|string[]> headers = {}) returns GuildBanResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/bans/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # ban_user_from_guild
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 204 response for ban_user_from_guild 
    resource isolated function put guilds/[string guildId]/bans/[string userId](GuildsBansRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/bans/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # unban_user_from_guild
    #
    # + guildId - Guild ID
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for unban_user_from_guild 
    resource isolated function delete guilds/[string guildId]/bans/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/bans/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # list_guild_bans
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for list_guild_bans 
    resource isolated function get guilds/[string guildId]/bans(map<string|string[]> headers = {}, *ListGuildBansQueries queries) returns GuildBanResponse[]|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/bans`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # set_guild_mfa_level
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for set_guild_mfa_level 
    resource isolated function post guilds/[string guildId]/mfa(GuildMFALevelResponse payload, map<string|string[]> headers = {}) returns GuildMFALevelResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}/mfa`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # get_stage_instance
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_stage_instance 
    resource isolated function get stage\-instances/[string channelId](map<string|string[]> headers = {}) returns StageInstanceResponse|error {
        string resourcePath = string `/stage-instances/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_stage_instance
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_stage_instance 
    resource isolated function delete stage\-instances/[string channelId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/stage-instances/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_stage_instance
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_stage_instance 
    resource isolated function patch stage\-instances/[string channelId](StageInstancesRequest1 payload, map<string|string[]> headers = {}) returns StageInstanceResponse|error {
        string resourcePath = string `/stage-instances/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_application
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_application 
    resource isolated function get applications/[string applicationId](map<string|string[]> headers = {}) returns PrivateApplicationResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # update_application
    #
    # + applicationId - Application ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_application 
    resource isolated function patch applications/[string applicationId](ApplicationFormPartial payload, map<string|string[]> headers = {}) returns PrivateApplicationResponse|error {
        string resourcePath = string `/applications/${getEncodedUri(applicationId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_webhook_by_token
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_webhook_by_token 
    resource isolated function get webhooks/[string webhookId]/[string webhookToken](map<string|string[]> headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # execute_webhook
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload -
    # + return - 200 response for execute_webhook 
    resource isolated function post webhooks/[string webhookId]/[string webhookToken](WebhookIdwebhookTokenBody payload, map<string|string[]> headers = {}, *ExecuteWebhookQueries queries) returns MessageResponse|error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # delete_webhook_by_token
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_webhook_by_token 
    resource isolated function delete webhooks/[string webhookId]/[string webhookToken](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_webhook_by_token
    #
    # + webhookId - Webhook ID
    # + webhookToken - Webhook Token
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_webhook_by_token 
    resource isolated function patch webhooks/[string webhookId]/[string webhookToken](WebhooksRequest1 payload, map<string|string[]> headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/${getEncodedUri(webhookToken)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_sticker
    #
    # + stickerId -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_sticker 
    resource isolated function get stickers/[string stickerId](map<string|string[]> headers = {}) returns InlineResponse2005|error {
        string resourcePath = string `/stickers/${getEncodedUri(stickerId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # get_webhook
    #
    # + webhookId - Webhook ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_webhook 
    resource isolated function get webhooks/[string webhookId](map<string|string[]> headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_webhook
    #
    # + webhookId - Webhook ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_webhook 
    resource isolated function delete webhooks/[string webhookId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_webhook
    #
    # + webhookId - Webhook ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_webhook 
    resource isolated function patch webhooks/[string webhookId](WebhooksRequest2 payload, map<string|string[]> headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_channel
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_channel 
    resource isolated function get channels/[string channelId](map<string|string[]> headers = {}) returns InlineResponse2006|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_channel
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for delete_channel 
    resource isolated function delete channels/[string channelId](map<string|string[]> headers = {}) returns InlineResponse2006|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_channel
    #
    # + channelId - Channel ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_channel 
    resource isolated function patch channels/[string channelId](ChannelschannelIdBody payload, map<string|string[]> headers = {}) returns InlineResponse2006|error {
        string resourcePath = string `/channels/${getEncodedUri(channelId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # invite_resolve
    #
    # + code -
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for invite_resolve 
    resource isolated function get invites/[string code](map<string|string[]> headers = {}, *InviteResolveQueries queries) returns InlineResponse2002|error {
        string resourcePath = string `/invites/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # invite_revoke
    #
    # + code -
    # + headers - Headers to be sent with the request 
    # + return - 200 response for invite_revoke 
    resource isolated function delete invites/[string code](map<string|string[]> headers = {}) returns InlineResponse2002|error {
        string resourcePath = string `/invites/${getEncodedUri(code)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # get_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response for get_guild 
    resource isolated function get guilds/[string guildId](map<string|string[]> headers = {}, *GetGuildQueries queries) returns GuildWithCountsResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # delete_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + return - 204 response for delete_guild 
    resource isolated function delete guilds/[string guildId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # update_guild
    #
    # + guildId - Guild ID
    # + headers - Headers to be sent with the request 
    # + payload -
    # + return - 200 response for update_guild 
    resource isolated function patch guilds/[string guildId](GuildPatchRequestPartial payload, map<string|string[]> headers = {}) returns GuildResponse|error {
        string resourcePath = string `/guilds/${getEncodedUri(guildId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # get_user
    #
    # + userId - User ID
    # + headers - Headers to be sent with the request 
    # + return - 200 response for get_user 
    resource isolated function get users/[string userId](map<string|string[]> headers = {}) returns UserResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }
}
